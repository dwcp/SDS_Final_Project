---
title: "Analysis of Predictors of Price and Popularity of Steam Games in 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lubridate)
library(dplyr)
library(naniar)
library(randomForest)

games <- read.csv("./games-features.csv", header=TRUE, stringsAsFactors = FALSE)
# games <- read.csv("https://query.data.world/s/4pach4x76ozrfmeavwsg6b4ja4qakj", header=TRUE, stringsAsFactors=FALSE);
```

## Introduction

This is a dataset on all steam games scraped from public Steam APIs and steamspy.com. The dataset comes from data.world at this url: https://data.world/craigkelly/steam-game-data. The dataset has 78 columns and includes things like price, descriptions and release date. According to the data on Github, the repository was created in Septembere 12, 2016 so we are assuming that the data also comes from the end of the year in 2016. The dataset has the following columns:

QueryID - (Integer) The original ID in idlist.csv

ResponseID - (Integer) The ID returned in the Steam response (should equal QueryID)

QueryName - (Text) The original name in idlist.csv

ResponseName - (Text) The name returned in the Steam response (should equal QueryName)

ReleaseDate - (Text) Appears to the be the initial release date for the game

RequiredAge - (Integer) list named required_age in JSON

DemoCount - (TextualCount) list named demos in JSON

DeveloperCount - (TextualCount) list named developers in JSON

DLCCount - (TextualCount) list named dlc in JSON

Metacritic - (Integer) numeric score from metacritic object in JSON

MovieCount - (TextualCount) list named movies in JSON (used object id for unique count)

PackageCount - (TextualCount) list named packages in JSON

RecommendationCount - (Integer) from recommendations.total in JSON

PublisherCount - (TextualCount) list named publishers in JSON

ScreenshotCount - (TextualCount) list named screenshots in JSON

AchievementCount - (Integer) achievements.total in JSON

AchievementHighlightedCount - (TextualCount) for achievements.highlighted in JSON

ControllerSupport - (Boolean) True if controller_support was full

IsFree - (Boolean) is_free in JSON

FreeVerAvail - (Boolean) True if is_free_license is True in package_groups list

PurchaseAvail - (Boolean) True if price_in_cents_with_discount greater than 0 in package_groups list

SubscriptionAvail - (Boolean) True if is_recurring_subscription is True in package_groups

PlatformWindows - (Boolean) True if platforms.windows is True

PlatformLinux - (Boolean) True if platforms.linux is True

PlatformMac - (Boolean) True if platforms.mac is True

PCReqsHaveMin - (Boolean) True if pc_requirements.minimum is non-empty string

PCReqsHaveRec - (Boolean) True if pc_requirements.recommended is non-empty string

LinuxReqsHaveMin - (Boolean) True if linux_requirements.minimum is non-empty string

LinuxReqsHaveRec - (Boolean) True if linux_requirements.recommended is non-empty string

MacReqsHaveMin - (Boolean) True if mac_requirements.minimum is non-empty string

MacReqsHaveRec - (Boolean) True if mac_requirements.recommended is non-empty string

CategorySinglePlayer - (Boolean) True if for any i, categories[i].description is "single-player"

CategoryMultiplayer - (Boolean) True if for any i, categories[i].description is one of: "cross-platform multiplayer", "local multi-player", "multi-player", "online multi-player", "shared/split screen"

CategoryCoop - (Boolean) True if for any i, categories[i].description is one of: "co-op", "local co-op", "online co-op"

CategoryMMO - (Boolean) True if for any i, categories[i].description is "mmo"

CategoryInAppPurchase - (Boolean) True if for any i, categories[i].description is "in-app purchases"

CategoryIncludeSrcSDK - (Boolean) True if for any i, categories[i].description is "includes source sdk"

CategoryIncludeLevelEditor - (Boolean) True if for any i, categories[i].description is "includes level editor"

CategoryVRSupport - (Boolean) True if for any i, categories[i].description is "vr support"

GenreIsNonGame - (Boolean) True if for any i, genres[i].description is one of: "utilities", "design & illustration", "animation & modeling", "software training", "education", "audio production", "video production", "web publishing", "photo editing", "accounting"

GenreIsIndie - (Boolean) True if for any i, genres[i].description is "indie"

GenreIsAction - (Boolean) True if for any i, genres[i].description is "action"

GenreIsAdventure - (Boolean) True if for any i, genres[i].description is "adventure"

GenreIsCasual - (Boolean) True if for any i, genres[i].description is "casual"

GenreIsStrategy - (Boolean) True if for any i, genres[i].description is "strategy"

GenreIsRPG - (Boolean) True if for any i, genres[i].description is "rpg"

GenreIsSimulation - (Boolean) True if for any i, genres[i].description is "simulation"

GenreIsEarlyAccess - (Boolean) True if for any i, genres[i].description is "early access"

GenreIsFreeToPlay - (Boolean) True if for any i, genres[i].description is "free to play"

GenreIsSports - (Boolean) True if for any i, genres[i].description is "sports"

GenreIsRacing - (Boolean) True if for any i, genres[i].description is "racing"

GenreIsMassivelyMultiplayer - (Boolean) True if for any i, genres[i].description is "massively multiplayer"

PriceCurrency - (Text) price_overview.currency in JSON

PriceInitial - (Float) price_overview.initial in JSON, divided by 100.0 to converts cents to currency

PriceFinal - (Float) price_overview.final in JSON, divided by 100.0 to converts cents to currency

SteamSpyOwners - (steamspy.com) total owners, which includes free weekend trials and other possibly spurious numbers.

SteamSpyOwnersVariance - (steamspy.com) total owners, which includes free weekend trials and other possibly spurious numbers. Note that this is not technically variance: according to steamspy.com, "the real number... lies somewhere on... [value +/- variance]"

SteamSpyPlayersEstimate - (steamspy.com) best estimate of total number of people who have played the game since March 2009

SteamSpyPlayersVariance - (steamspy.com) errors bounds on SteamSpyPlayersEstimate. Note that this is not technically variance: according to steamspy.com, "the real number... lies somewhere on... [value +/- variance]"

SupportEmail - (Textual) support_info.email in JSON

SupportURL - (Textual) support_info.url in JSON

AboutText - (Textual) about_the_game in JSON

Background - (Textual) background in JSON

ShortDescrip - (Textual) short_description in JSON

DetailedDescrip - (Textual) detailed_description in JSON

DRMNotice - (Textual) drm_notice in JSON

ExtUserAcctNotice - (Textual) ext_user_account_notice in JSON

HeaderImage - (Textual) header_image in JSON

LegalNotice - (Textual) legal_notice in JSON

Reviews - (Textual) reviews in JSON

SupportedLanguages - (Textual) supported_languages in JSON

Website - (Textual) website in JSON

PCMinReqsText - (Textual) text of pc_requirements.minimum

PCRecReqsText - (Textual) text of pc_requirements.recommended

LinuxMinReqsText - (Textual) text of linux_requirements.minimum

LinuxRecReqsText - (Textual) text of linux_requirements.recommended

MacMinReqsText - (Textual) text of mac_requirements.minimum

MacRecReqsText - (Textual) text of mac_requirements.recommended

Our goal is to discover interesting trends that allow us to predict how a game is price and it's popularity after release. The price is divided into price initial and price final. We are going to use price initial as our metric to determine price and SteamSpyOwners as a metric to predict popularity.

## Data Cleanup

From the above, we can see that there is a lot of information that is hard to use to predict price. One example is the description. Unless we can extract some kind of metric from this, we won't be able to use it to predict price. As such, we choose to remove the following columns: QueryID, ResponseID, PCMinReqsText, PCRecReqsText, MacMinReqsText, MacRecReqsText, LinuxMinReqsText, LinuxRecReqsText, Reviews, LegalNotice, HeaderImage, DRMNotice, ExtUserAcctNotice, ShortDescrip, Background, AboutText, PriceCurrency.

We then try and extract some useful information out of the other columns. We first need to transform all of the true/false columns to factors. We then need to change the date time format so that it can be easily read by R. 

```{r, echo=FALSE}
games <- subset(games, select = -c(QueryID, ResponseID, PCMinReqsText, PCRecReqsText, MacMinReqsText, MacRecReqsText, LinuxMinReqsText, LinuxRecReqsText, Reviews, LegalNotice, HeaderImage, DRMNotice, ExtUserAcctNotice, ShortDescrip, Background, AboutText, PriceCurrency))
col_names <- names(games)[20:54]
games[col_names] <- lapply(games[col_names] , factor)
games$ReleaseDate <- as.Date(games$ReleaseDate, format="%b %d %Y")
which(games$ReleaseDate < as.Date("1800-01-01"))

delete <- games$ReleaseDate[which(games$ReleaseDate < as.Date("1800-01-01"))]
games <- (games %>% replace_with_na(replace = list(ReleaseDate = delete)))
```

Now, we changed the Supported Languages column to contain the total number of supported languages, instead of the specific languages. 
```{r, echo=FALSE}
games$SupportedLanguages <- (str_remove(games$SupportedLanguages, "languages with full audio support"))
games$SupportedLanguages <- (str_remove(games$SupportedLanguages, "Simplified "))
games$SupportedLanguages <- (str_remove(games$SupportedLanguages, "Traditional "))
games$SupportedLanguages <- lapply(strsplit(games$SupportedLanguages, " "), length ) 
games$SupportedLanguages <- sapply(games$SupportedLanguages, unlist )
```

Next, we modified the Detailed Description field to contain the number of words. 
```{r, echo=FALSE}
games$DetailedDescrip <- lapply(strsplit(games$DetailedDescrip, " "), length )
games$DetailedDescrip <- sapply(games$DetailedDescrip, unlist )
#typeof(games$DetailedDescrip[1])

```

We consolidated the Support Email and Support URL columns into a single column called Support, which holds a binary value based on whether a game has either a support email or a support URL.  
```{r, echo=FALSE}
 games$Support <- ifelse(
    ( 
        (games$SupportEmail != " ") |
        (games$SupportURL != " ")
    ),
    TRUE,  # if condition is met, put 1
    FALSE   # else put 0
)
```
We changed the Website column to indicate whether or not a website was provided
```{r, echo=FALSE}
 games$Website <- ifelse(
    ( 
        (games$Website != "None")
    ),
    TRUE,  # if condition is met, put 1
    FALSE   # else put 0
)
games <- subset(games, select = -c(PriceFinal, SupportEmail, SupportURL, IsFree, SteamSpyOwnersVariance, SteamSpyPlayersVariance))
```

## Principle Components Analysis
Using principal component analysis, we tried to reduce the dimensions of the data given to something that is easier to interpret. The components extracted using the PCA function are as follows:
```{r, include=FALSE}
# no model matrix for wine type because all variables are numerical
set.seed(1)
# Clustering using PCA
# using all 56 variables
games_model <- model.matrix(PriceInitial ~. - (QueryName + ResponseName) - 1, data = games)
games.pca <- prcomp(games_model[,c(1:54)], center = TRUE, scale. = TRUE)
summary(games.pca)
games_model
loadings = games.pca$rotation

```

```{r, echo=FALSE}
loadings[,1] %>% sort (decreasing = TRUE)
```

This first component explains the most variance out of all the components. The most significant coefficient indicates whether a Free version is avaiable. This makes sense because games that have a frere or trial version will get players hooked to purchase the full, more costly version. Release Date is another significant Coefficient, and suggests that newer games have higher prices. 

```{r, echo=FALSE, R.options=list(max.print=10)}
loadings[,2] %>% sort (decreasing = TRUE)
```

The second component seems indicative of PC games due to the highest component being lack of controller support. Thus, we can conclude this category contains older AAA high budget games due to the low emphasis on release date as well as a high emphasis on number of Publishers and Developers. 
```{r, echo=FALSE, R.options=list(max.print=10)}
loadings[,3] %>% sort (decreasing = TRUE)
```
The third component describes niche indie games. We can conclude this because of the positive emphasis on the coefficients of Single Plater Games, Casual Games, and Indie Games as well as a negative emphasis on Number of owners and Number of Players. 

```{r, echo=FALSE, R.options=list(max.print=10)}
loadings[,4] %>% sort (decreasing = TRUE)
```

The fourth component seems to describe newer multiplayer games. This is due to the high positive coefficients of Massive Multiplayer Genre, Release Date, and MMO Category.

We couldn't accurately determine the subset of the fifth component, so we decided to stop any further PCA analysis. 

## Tree
### Initial Price
```{r, echo=FALSE}
games2 <- subset(games, select = -c(QueryName , ResponseName))
games2 <- na.omit(games2)
n = nrow(games2)
n_train = floor(0.8*n)
n_test = n - n_train
train_cases = sample.int(n, size=n_train, replace=FALSE)

y_all = games2$PriceInitial
x_all = model.matrix(~. - PriceInitial, data=games2)

y_train = y_all[train_cases]
x_train = x_all[train_cases,]

y_test = y_all[-train_cases]
x_test = x_all[-train_cases,]

forest1 = randomForest(x=x_train, y=y_train, xtest=x_test)
yhat_test = (forest1$test)$predicted

plot(yhat_test, y_test)
plot(forest1) 
varImpPlot(forest1)

```

### Metacritic 
```{r, echo=FALSE}
games3 <- subset(games, select = -c(QueryName , ResponseName))
games3 <- na.omit(games3)
n = nrow(games3)
n_train = floor(0.8*n)
n_test = n - n_train
train_cases = sample.int(n, size=n_train, replace=FALSE)

y_all = games3$Metacritic
x_all = model.matrix(~. - Metacritic, data=games3)

y_train = y_all[train_cases]
x_train = x_all[train_cases,]

y_test = y_all[-train_cases]
x_test = x_all[-train_cases,]

forest1 = randomForest(x=x_train, y=y_train, xtest=x_test)
yhat_test = (forest1$test)$predicted

plot(yhat_test, y_test)
plot(forest1) 
varImpPlot(forest1)

```








